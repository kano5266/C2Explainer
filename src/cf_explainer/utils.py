from typing import Union, Optional

import random
import numpy as np
import torch
from torch import Tensor

from torch_geometric.explain.algorithm import ExplainerAlgorithm
from torch_geometric.utils import k_hop_subgraph, to_undirected, coalesce


def subgraph(model: torch.nn.Module,
             index: Optional[Union[int, Tensor]],
             x: Tensor,
             edge_index: Tensor,
             target: Tensor,
             additional_hop: int = 0,
             relabel_nodes = True
             ):

    subset, edge_index, index, edge_mask = k_hop_subgraph(
        index,
        num_hops=ExplainerAlgorithm._num_hops(model)+additional_hop,
        edge_index=edge_index,
        relabel_nodes=relabel_nodes,
        num_nodes=x.size(0),
        flow=ExplainerAlgorithm._flow(model))

    return x[subset], edge_index, index.item(), edge_mask, target[subset]


def seed_everything(seed, deterministic=False):
    random.seed(seed)
    np.random.seed(seed)
    torch.manual_seed(seed)
    torch.cuda.manual_seed_all(seed)
    if deterministic:
        torch.backends.cudnn.deterministic = True
        torch.use_deterministic_algorithms(True)


def to_cfexplanation(explanation, model):
    r"""
    Input:
        explanation: factual explanation generated by factual explainer
            e.g., GNNExplainer, PGExplainer
        model: prediction model like GCN
    """
    edge_mask = explanation.edge_mask
    edge_index = explanation.edge_index
    if hasattr(explanation, "index"):
        index = explanation.index
    x = explanation.x

    f_mask = edge_mask.to(bool)  # directed mask
    f_edge_index = edge_index[:, f_mask]
    f_edge_index = to_undirected(f_edge_index)

    num_perturbs = f_edge_index.shape[1]
    
    if hasattr(explanation, "index"):
        _, sub_edge_index, _, _ = k_hop_subgraph(
            index, num_hops=ExplainerAlgorithm._num_hops(model),
            edge_index=edge_index,
            relabel_nodes=True,
            num_nodes=x.size(0),
            flow=ExplainerAlgorithm._flow(model))
    else:
        sub_edge_index = edge_index
    prob_perturbs = num_perturbs/sub_edge_index.shape[1]

    # Trick from https://github.com/pyg-team/pytorch_geometric/discussions/9440
    # It is non-trival to remove edges from a graph stored as COO format.
    # But there is a tricky way to remove edges from edge_index by merging them first:
    all_edge_index = torch.cat([edge_index,
                                f_edge_index], dim=1)

    # mark removed edges as 1 and 0 otherwise
    all_edge_weights = torch.cat([torch.zeros(edge_index.size(1)),
                                  torch.ones(f_edge_index.size(1))]).to(all_edge_index.device)

    all_edge_index, all_edge_weights = coalesce(
        all_edge_index, all_edge_weights)

    # remove edges indicated by 1
    cf_edge_index = all_edge_index[:, all_edge_weights == 0]
    

    if hasattr(explanation, "index"):
        y = model(x, edge_index)[index]
        y_cf = model(x, cf_edge_index)[index]
    else:
        y = model(x, edge_index, batch=None)[0]
        y_cf = model(x, cf_edge_index, batch=None)[0]

    if y.argmax() != y_cf.argmax():
        success = 1
    else:
        success = 0
    return success, num_perturbs, prob_perturbs


def diff(edge_index1, edge_index2):
    edges1 = edge_index1.t()
    edges2 = edge_index2.t()

    # Find unique edges in edge_index1
    unique_edges1 = torch.empty((0, 2), dtype=torch.long).to(edge_index1.device)
    for edge in edges1:
        if not any((edge == edges2).all(dim=1)):
            unique_edges1 = torch.cat((unique_edges1, edge.unsqueeze(0)), dim=0)

    # Find unique edges in edge_index2
    unique_edges2 = torch.empty((0, 2), dtype=torch.long).to(edge_index2.device)
    for edge in edges2:
        if not any((edge == edges1).all(dim=1)):
            unique_edges2 = torch.cat((unique_edges2, edge.unsqueeze(0)), dim=0)

    # Transpose to get back to edge_index format
    unique_edge_index1 = unique_edges1.t()
    unique_edge_index2 = unique_edges2.t()

    print("Edges in added:")
    print(unique_edge_index1)

    print("Edges in deleted:")
    print(unique_edge_index2)
